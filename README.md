
<div align="center">
  <img src="feature_modelling_logo.png" width="300px">

  <br><br>

  <p align="center">
    <a href="#project-overview">Overview</a> •
    <a href="#architecture">Architecture</a> •
    <a href="#feature-model-overview--layout">Feature Model</a> •
    <a href="#server-side-services--handlers">Server-Side</a> •
    <a href="#client-limitations-and-customizations">Client Customizations</a> •
    <a href="#server–client-integration">Clients Integration</a> •
    <a href="#emf-model">EMF Model</a> •
    <a href="#building-the-project">Build</a> •
    <a href="#running-and-debugging-the-example">Run</a> •
    <a href="#bugs-and-known-issues">Issues</a>
  </p>
</div>

---


# GLSP Feature Modeler 

## Project Overview

**GLSP Feature Modeler** is a **team university project** aiming to design and implement a **GLSP-based diagram editor** using **Java / EMF**. The project focuses on:

- Creating, visualizing, and editing **feature nodes** (`featJAR.Feature`) in a **model-driven approach**.
- Ensuring **stable ID mapping**, **undo/redo support**, and proper **visual distinction** between **optional** and **obligatory** features.
- Producing **documentation, code structure**, and a **working prototype** for assessment.






## Short description
`GLSP Feature Modeler` extends a GLSP Java/EMF server to manage and render `featJAR.Feature` elements as diagram nodes (GNodes). Users create nodes from the client; the server updates the EMF semantic and notation models and the GModel factory converts those models into shapes and labels the client renders. The implementation ensures stable IDs, undo/redo support, and visual distinction between optional and obligatory features.






## Goal
- Implement reliable creation and visualization of feature nodes (`featJAR.Feature`) in a GLSP/EMF environment.
- Keep semantic (EMF) and notation models consistent and synchronized.
- Provide undo/redo support for creation operations.
- Ensure stable ID mapping between semantic elements and notation shapes.
- Render nodes with appropriate types (optional / obligatory) and labels taken from `Feature.name`.






## Architecture

### Client 

- Sends **operations** (`CreateNodeOperation`, `DeleteOperation`, etc.) to the server.
- Renders **GModel elements** (`GGraph`, `GNode`, `GLabel`) provided by the server.

### Server (GLSP Java / EMF)

- **Operation Handlers** manage incoming operations and create/update EMF semantic and notation elements.
- **EditingDomain** and EMF `Command`s handle transactional updates.
- **EMFIdGenerator** ensures stable **semantic ↔ notation mapping**.

### Models

- **Semantic Model:** `featJAR.Feature` stores domain information (name, optional/root flags).  
- **Notation Model:** Diagram positions and sizes for rendering.  
- **GModel:** Client-facing graphical model generated by **GModel Factory**.

### GModel Factory (`TaskListGModelFactory`)

- Converts semantic + notation models into **GNodes/GLabels** for rendering.
- Applies **position, size, and styling** (node types: optional/obligatory).






## Feature Model Overview & Layout(optional part, mentioned before)

### Overview & Functions
- Auto-layout of feature tree.
- Feature markers above labels: filled = optional, hollow = obligatory/root.
- Constraints box: X centered at root, Y below rightmost leaf.

### Technology & Architecture
- Server: GLSP + EMF.
- Model: `featJAR.FeatureModel`.
- Rendering: `FeatureModelGModelFactory` generates GNodes/GEdges; `FeatureTreeLayouter` computes positions.
- Styling: CSS classes for Root/Obligatory/Optional nodes and markers.

### Key Updates
- **Styling (CSS)**: consistent palette, shadows, SVG circle markers.
  - Classes: `.feature-node-root`, `.feature-node-obligatory`, `.feature-node-optional`
  - Marker classes: `.feature-marker`, `.feature-marker-optional`, `.feature-marker-mandatory`
- **Server (FeatureModelGModelFactory)**:
  - VBox layout: marker + label
  - Child resolution: Feature → groups → features or Feature → features
  - Edges as GEdge
  - Constraints box: X at root, Y via anchor below rightmost leaf (`marginY`)
- **FeatureTreeLayouter**:
  - In-order layout: leaves sequential X, Y = level
  - Internal nodes centered over children
  - Helpers: `findRightmostLeaf`, `computeAnchorBelowRightmostLeaf`
  - Mapping TreeNode ↔ GNode

### Configuration & Tuning
- `horizontalGap` / `verticalGap`: spacing between nodes
- `nodeWidth` / `nodeHeight`: minimum node size
- Marker size: `16x16`
- Constraint box spacing: `marginY` at anchor





## **Server-Side Services & Handlers**

### **Configuration: Diagram Editing Permissions**

**Purpose**  
In the Class **FeatureModelDiagramConfiguration**, defines what actions are allowed on nodes and edges in the feature model diagram, ensuring that users can only perform valid operations.

**What it does**  
- Specifies which elements can be **moved, deleted, resized, or reparented**.  
- Ensures that some elements (like root nodes) are fixed and cannot be resized or recreated.  
- Controls links: creation and deletion are allowed, reconnection is restricted.

### **Class: FeatureModelDiagramModule**

**Purpose**  
Connects all services, factories, and handlers for the feature model diagram, defining how elements are created, edited, and displayed.

**What it does**  
- Binds **diagram configuration**, **GModel factory**, **model storage**, and **ID generator**.  
- Registers **tool palette**, **label validator**, and **operation handlers** for creating and renaming nodes.  
- Defines the diagram type for GLSP (`tasklist-diagram`).

**Result**  
- Centralizes diagram setup and ensures consistent behavior for node creation, editing, and rendering.

### **Class: FeatureModelTypes**

**Purpose**  
Defines the mapping between EMF model elements and GModel types, ensuring the client can correctly render and handle each element.

**What it does**  
- Assigns **node types** for `ROOT`, `OPTIONAL_FEATURE`, and `OBLIGATORY_FEATURE`.  
- Assigns **edge types** for `CONSTRAINT` and `LINK`.  
- Ensures every GModel type is recognized and supported by the client for rendering and interaction.

**Result**  
- Provides a consistent reference for all semantic elements when converting them to GModel nodes and edges.  
- Guarantees that the client knows how to display and interact with each feature or connection type.

### **Class: FeatureTreeLayouter**

**Purpose**  
Provides an **automatic tree layout** for feature nodes, calculating positions for each node based on the tree structure.

**What it does**  
- Represents nodes as **TreeNode** objects, tracking children and coordinates.  
- Uses a **recursive layout algorithm** (`computePositions`) to calculate `x` and `y` positions for all nodes.  
- Maps between **TreeNode** instances and **GNode** objects used in the diagram.  
- Maintains a static list of all tree nodes for easy reference.  
- Provides utility methods to **clear layout** or retrieve nodes by ID.

**Result**  
- Ensures a clear hierarchical layout of feature nodes in the diagram.  
- Automatically positions internal and leaf nodes to produce an organized tree structure.  
- Supports mapping between semantic GModel nodes and layout nodes for rendering.

### **Creation Operation Handlers**

**Purpose**  
These handlers manage the **creation of nodes and edges** in the feature model diagram. They are triggered by client operations to add **features** (obligatory or optional) or **constraints** between features.  

**Handlers Included**  
- **CreateConstraintOperationHandler** – Creates new **constraint edges**.  
- **CreateObligatoryFeatureNodeHandler** – Creates new **obligatory feature nodes**.  
- **CreateOptionalFeatureNodeHandler** – Creates new **optional feature nodes**.  

**What They Do (Common Workflow)**  
1. Receive a **`CreateNodeOperation`** from the client.  
2. Determine the **parent element** in the EMF model:  
   - If a feature is selected, it becomes the parent.  
   - If no selection exists, the **root feature** or **feature model** is used as the parent.  
3. Create a new **EMF element** (Feature or Constraint) using the **FeatJARFactory**.  
4. Assign a **unique ID** to the new element using **EMFIdGenerator**.  
5. Build an **EMF `AddCommand`** to add the element to the parent in the semantic model.  
6. Wrap the command in a **`CompoundCommand`** to support transactional operations and **undo/redo**.  
7. Return the command to be executed by the **EditingDomain**.  



**Result**  
- Users can **create new features and constraints** in the diagram via the client.  
- Changes are immediately reflected in:  
  - **Semantic EMF model** (featJAR elements).  
  - **Graphical GModel** (nodes/edges in the client).  
- All creation operations support **undo/redo** and maintain **stable IDs**.

### **Delete Operation Handler**

**Purpose**  
The **DeleteFeatureNodeHandler** manages the **deletion of feature nodes** in the feature model diagram.  
It ensures that removed elements are deleted both from the **semantic EMF model** and the **graphical GModel**.

**What It Does**  
1. Receives a **`DeleteOperation`** from the client, containing a list of **GModel element IDs** to remove.  
2. Maps each GModel ID to the corresponding **EMF `Feature`** using `FeatureModelGModelFactory.featureIdMap`.  
3. Creates a **`RemoveCommand`** for each element:  
   - Removes the element from its **parent container** in the semantic model.  
   - Maintains EMF transactional integrity for undo/redo support.  
4. Combines all individual remove commands into a **`CompoundCommand`** for execution.  

**Utility**  
- **`findFeatureById(String id)`** – Searches the list of all EMF features (`FeatureModelGModelFactory.emfFeatures`) to locate a feature by its ID.  
- Handles cases where the feature list or ID is `null` gracefully.  

**Result**  
- Features selected for deletion are removed from the **EMF model** and subsequently from the **diagram** on the client.  
- Supports **undo/redo** via EMF transactional commands.  
- Ensures consistent mapping between semantic and graphical models after deletion.

### **Class: FeatureModelLabelEditValidator**

**Purpose**  
Handles **server-side validation** when a label of a diagram element is edited, ensuring correctness and uniqueness.

**What it does**  
- Validates that a label is **not empty**.  
- Checks for **duplicate labels** among other nodes and issues a warning if the name is already used.  
- Supports **direct editing** of node labels from the client, typically triggered by a double-click.  
- Currently, the **client-side operation** to initiate label editing is not fully implemented and requires a custom element for double-click editing.

**Result**  
- Ensures node labels remain meaningful and mostly unique.  
- Prevents empty names and informs users about potential conflicts.  
- Lays the foundation for safe client-side label editing once the corresponding client feature is implemented.

### **Class: Label Edit Validator**

**Purpose**  
Validates feature node labels to ensure they are not empty and mostly unique.

**What It Does**  
- **Empty check:** Returns an error if the label is empty.  
- **Duplicate check:** Warns if another node already has the same label.  
- **Default:** Returns OK if valid.

**Result**  
- Keeps labels meaningful and mostly unique.  
- Lays the foundation for safe direct editing from the client.

### **Paste Operation Handler(Incomplete)**

**Purpose**  
Handles **paste operations** for feature model constraints, allowing users to duplicate or insert new constraints from clipboard data.

**What It Does**  
- Reads the **last entry** from the clipboard data in the `PasteOperation`.  
- Creates a new **Constraint** instance using the clipboard value.  
- Adds the new constraint to the **FeatureModel** using an EMF `AddCommand`.  
- Wraps the command in a **CompoundCommand** for execution.  
- Assigns a **unique ID** to the new constraint using `EMFIdGenerator`.

**Result**  
- Enables **pasting constraints** into the EMF model safely.  
- Maintains consistency with existing model elements and generates unique identifiers.

### **Selection Action Handler**

**Purpose**  
Handles **selection actions** in the diagram, tracking which feature node is currently selected by the user.

**What It Does**  
- Checks if the incoming action is a **SelectAction**.  
- Retrieves the **selected element IDs** from the action.  
- Looks up the corresponding **Feature** in the model using `FeatureModelGModelFactory`.  
- Updates the **model state property** `"currentSelection"` with the selected feature.

**Result**  
- Maintains a reference to the **currently selected node** in the EMF model.  
- Enables other operations (e.g., create child nodes) to use the selected node as a **parent**.

### **FeatureModelToolPaletteItemProvider**

**Purpose**  
Defines and designs the **client-side tool palette**, allowing users to view information about elements and perform creation operations using custom icons.

**What it does**  
- Provides **node creation tools** for `Optional Feature`, `Obligatory Feature`, and `Constraint`.  
- Creates an **information legend** showing node and group types with labels and icons for quick reference.  
- Uses **custom icons** to visually distinguish element types in the palette.  
- Combines all palette items into **groups**: one for creating nodes, one for informational legend.  

**Result**  
- Users can easily **create new nodes** and understand the diagram elements at a glance.  
- The tool palette improves usability by showing both **actions** (create nodes) and **informational cues** (legend).  
- Supports consistent and intuitive interaction with the diagram editor.

### **Popup Model Factory(Incomplete)**

**Purpose**  
Generates **popup tooltips** for feature nodes to show contextual information.

**What It Does**  
- Creates HTML popups (`GHtmlRoot`) with labels (`GLabel`) for each node type.  
- Shows descriptions for root, obligatory, and optional features.  
- Applies CSS classes for styling (`glsp-tooltip`, `tooltip`).  

**Result**  
- Provides **informative tooltips** for feature nodes.  
- Fully integrated with the GLSP client for hover feedback.




### **FeatureModelGModelFactory**

**Purpose:**  
Converts the EMF semantic model (`featJAR.FeatureModel`) and notation model (`Diagram`) into a client-renderable GModel. Manages nodes, edges, labels, and constraint legends.

**Key Features:**
- Tracks all GModel elements (`GNode`, `GEdge`) and maps semantic IDs to graphical IDs.
- Creates nodes for root, optional, and obligatory features with proper CSS styling.
- Connects parent and child features with edges.
- Automatically lays out the feature tree using `FeatureTreeLayouter`.
- Creates a constraint legend box under the rightmost leaf, dynamically sized.
- Provides utilities for labels and separators in the constraints box.
- Clears previous elements and mappings for consistent redraws.

**Result:**  
Ensures a consistent and visually organized diagram, linking EMF features to graphical nodes, supporting auto-layout, ID stability, and constraint visualization.






## Client Limitations and Customizations

### Custom Shapes
- Added **custom SVG shapes** for feature nodes.  
- **Size cannot be dynamic** because SVG uses absolute paths, so nodes do not scale automatically.  
- Custom shapes work visually, but resizing is limited.

### Icons and Images
- Tried to render **icons using SVG or image files**, but they did not appear correctly on the client.  
- Included asset paths via **Webpack**, but images were still not rendered.  
- Adding **custom icons** is difficult because the font bundle must be rebuilt and remapped, making it non-trivial.

### CSS Customizations
- Added **custom CSS classes** for each EMF class to improve visual styling.  
- This allows partial visual customization without modifying the core client code.  

### Summary
- **Custom shapes** are possible, but **resizing and dynamic rendering** are limited.  
- **Icons and images** are difficult to integrate due to client-side limitations.  
- **CSS classes** provide the easiest way to visually distinguish EMF elements.
## Server–Client Integration

### Purpose
To connect the **GLSP server** with two client environments — one in **Visual Studio Code** and one in **Theia** — enabling model editing and visualization across both platforms.

### What we did
- Set up and configured the **GLSP server** for communication with both clients.  
- Attempted to integrate **diagram rendering and operation handling** between the server and the two clients.  
- Adjusted connection settings and ports to enable proper synchronization.

### Problems Encountered
- The **Visual Studio Code integration** was difficult due to issues **finding and configuring the correct port**.  
- The **Theia client could not connect** because of internal **server configuration or startup issues**, preventing successful communication.  
- Overall integration was unstable, requiring more debugging on both server and client sides.

### Result
- Partial integration achieved, with communication working inconsistently.  
- Identified key issues related to **port configuration** and **server setup** that must be fixed for full client compatibility.  
- Gained better understanding of the **GLSP communication flow** between server and client environments.
## **EMF Model**

The **GLSP server** uses an **EMF model** that represents the **FeatJAR model**, currently in a simplified form.  
The model is located at:  
`FeatJAR/FeatJAR-gui/src/main/model`.

To modify the EMF model, it is **recommended to use Eclipse Modeling Tools**.  
You can import the project into Eclipse as an existing project.  
If the **class diagram** does not appear automatically, navigate to:  
`featJAR/model/featJAR.aird/Design/Entities in a Class Diagram/featJAR`  
and double-click on it to open.

Once the class diagram is open, you can generate the model code:  
1. Go to `featJAR/model/featJAR.genmodel`.  
2. Right-click on **FeatJAR** in the opened tab.  
3. Select **Generate Model Code**.

---

## **Building the Project**

To build the **GLSP** part of the project, execute the following command in the repository root:**yarn build**

The overall project also includes a **Gradle wrapper**, but it is currently not functional.

---

## **Running and Debugging the Example**

To test the **TaskList diagram editor**, a launch configuration is already provided.  
In your Eclipse workspace, navigate to:  
`org.eclipse.glsp.example.javaemf.editor`

Then run or debug the example by right-clicking on **TaskListEditor.launch** and selecting:  
**Run As → TaskListEditor**

This will open a **second instance of Eclipse** with the GLSP TaskList editor plugins preinstalled.  
Import the provided example project into this workspace and open the `.tasklist` file to launch the diagram editor.



---

## **Translating Between EMF and FeatJAR Models**

Under  
`FeatJAR-gui/src/main/java/de/featjar/gui/`,  
there are two main translator classes:

- **TranslatorToEMF** – Converts a `FeatureModel` into `.featuremodel` and `.notation` files for the GLSP server/client to read.  
- **TranslatorFromEMF** – Reads a `.featuremodel` file and reconstructs a `FeatureModel`.

Additional details:  
- In `FeatJAR-gui/src/main/java/de/featjar/gui/EMFxmls/`, there is a `.uvl` file.  
- The `Gui.java` file creates a `.featuremodel` from this `.uvl` file along with other examples.  
- **Constraints** are not supported in the current version.  
- **Groups** are also not included but exist in another branch that supports them.

---

## **Bugs and Known Issues**

- **Removing elements** from the EMF model (in Eclipse Modeling Tools) can cause **code generation errors**.  
  - To fix this, delete the folder `featJAR/src-gen` and regenerate the model code.  
  - In some cases, you may need to recreate the entire Ecore project.  

- The **auto-layout feature** in the server is **not working as intended**.  
  - It incorrectly positions feature nodes when a parent node has more than three children.


---


